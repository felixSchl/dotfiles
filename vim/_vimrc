" vim: fdm=marker:
" Globals {{{
" -------------------------------------------------------------------------------
if !exists('g:chosen_color')
    let g:chosen_color = ""
endif
let s:is_initial=1
if !exists('g:initial_load')
    let g:initial_load=1
else
    let s:is_initial=0
endif

let s:ignore_dirs='\v[\/]((\.(git|hg|svn))|(build|obj|temp|Library))$'
let s:ignore_files='\v\.('
                 \.'meta|exe|so|dll|fbx|png|tga|jpg|bmp|csproj|sln|'
                 \.'unityproj|userprefs|suo|asset|prefab|db|dwlt|mdb|class|jar|'
                 \.'mat|apk|obb|cache|controller|user|ttf|guiskin|unity'
                 \.')$'
" }}}
" Init vundle {{{
" -------------------------------------------------------------------------------
let s:isWin=0
let s:isLinux=0
if has('win32') || has('win64')
  set rtp+=~/vimfiles/bundle/vundle/
  call vundle#rc('$HOME/vimfiles/bundle/')
  let s:isWin=1
else
  " Usual quickstart instructions
  set rtp+=~/.vim/bundle/vundle/
  call vundle#rc()
  let s:isLinux=1
endif
" }}}
" Mandatory settings {{{
" ------------------------------------------------------------------------------
set nocompatible
filetype indent plugin on
if (s:isWin)
    set shell=cmd
    set shellcmdflag=/c
endif
" }}}
" Mappings {{{
" ------------------------------------------------------------------------------
let mapleader = ","
let maplocalleader = "\\"
if (s:isWin)
    nmap <F2>           :e ~/_vimrc<CR>
    nmap <F3>           :so ~/_vimrc<CR>
    nmap <leader>E      :Start explorer %:h<CR>
    nmap <leader>C      :Start cmd /K cd /d "%:h"<CR>
else
    nmap <F2>           :e ~/.vimrc<CR>
    nmap <F3>           :so ~/.vimrc<CR>
    nmap <leader>E      :Start nautilus %:h<CR>
endif
nmap Q <Nop>

" Toggle cursor column
map <F11> :set cursorcolumn!<CR>

" Easier virtual editing
" block -> onemore -> off
func! Change_virtual_edit_mode()
    if (&ve=="block")
        let &ve="onemore"
    elseif (&ve=="onemore")
        let &ve=""
    elseif (&ve=="")
        let &ve="block"
    endif
    echo "Virtual edit mode is now: \"".&ve."\""
endfunc
set virtualedit="onemore"
nmap <F10> :call Change_virtual_edit_mode()<CR>

" " Select visual lines by default
" nmap j gj
" nmap k gk

" Swap v and CTRL-v (prefer block mode)
nnoremap    v   <C-V>
nnoremap <C-V>     v
vnoremap    v   <C-V>
vnoremap <C-V>     v

" Fastes insert mode leaving
imap jk <C-C>

" Quickly remove search highlight
nmap <F4> :nohl<CR>

" Easier copying and pasting
nmap <leader>p "*p
nmap <leader>P "*P
imap <C-_>     <C-R>
vmap <leader>y "*yy

" Start the current file as a command
nmap <leader>e :Start %s:h<CR>

" ':Wa' is not editor command annoyance
command! -bang Wa wa<bang>
command! -bang Wq wq<bang>

" Easier window navigation
nmap <C-H> <C-W>h
nmap <C-J> <C-W>j
nmap <C-K> <C-W>k
nmap <C-L> <C-W>l

" Easier tab navigation
nnoremap <C-S-tab> :tabprevious<CR>
nnoremap <C-tab>   :tabnext<CR>
nnoremap <C-t>     :tabnew<CR>
inoremap <C-S-tab> <Esc>:tabprevious<CR>i
inoremap <C-tab>   <Esc>:tabnext<CR>i
inoremap <C-t>     <Esc>:tabnew<CR>
nnoremap <C-Insert> :tabnew<CR>
nnoremap <C-Delete> :tabclose<CR>
nnoremap <A-F1> 1gt
nnoremap <A-F2> 2gt
nnoremap <A-F3> 3gt
nnoremap <A-F4> 4gt

" Mouse scrolling
map <ScrollWheelUp>     <C-Y>
map <S-ScrollWheelUp>   <C-U>
map <ScrollWheelDown>   <C-E>
map <S-ScrollWheelDown> <C-D>

" Always launch command editing window
" nmap : q:i
" nmap / q:i
" nmap ? q?i

" Faster substitute prompt
" Substitute with last search, confirm on/off
nmap <leader>r/ :%s:<C-R>/::gc<Left><Left><Left>
nmap <leader>R/ :%s:<C-R>/::g<Left><Left>
" Substitute from blank, confirm on/off
nmap <leader>; :%s:::g<Left><Left><Left>
nmap <leader>' :%s:::gc<Left><Left><Left><Left>

" }}}
" Bundles {{{
Bundle 'flazz/vim-colorschemes'
Bundle 'tpope/vim-dispatch'
Bundle 'endel/actionscript.vim'
Bundle 'tpope/vim-fugitive'
Bundle 'tsaleh/vim-matchit'
Bundle 'MarcWeber/vim-addon-mw-utils'
Bundle 'tomtom/tlib_vim'
Bundle 'garbas/vim-snipmate'
Bundle 'honza/vim-snippets'
Bundle 'tpope/vim-surround'
Bundle 'Townk/vim-autoclose'
Bundle 'vim-scripts/cg.vim'
Bundle 'dart-lang/dart-vim-plugin'
Bundle 'vim-scripts/VOoM'
Bundle 'vim-scripts/CRefVim'
Bundle 'ivyl/vim-bling'
Bundle 'Shougo/vimproc'
Bundle 'OrangeT/vim-csharp'
Bundle 'eagletmt/neco-ghc'
Bundle 'eagletmt/ghcmod-vim'
Bundle 'vim-scripts/Haskell-Conceal'
Bundle 'tpope/vim-repeat'
Bundle 'vim-scripts/ZoomWin'
Bundle 'tpope/vim-unimpaired'

Bundle 'Yggdroot/indentLine'
nmap <leader>ir :IndentLinesReset<CR>
nmap <leader>it :IndentLinesToggle<CR>
nmap <F12>      :IndentLinesToggle<CR>
let g:indentLine_noConcealCursor=1

Bundle 'godlygeek/tabular'
" Maps hotkeys for tabularize, repeatable by repeat.vim
function! s:make_align_mappings(first_key, ...)
    for tabmaps in a:000
        let second_key = tabmaps[0]
        let tabularize_args = tabmaps[1]
        let tabularize_cmd = ":Tabularize " . tabularize_args
        let repeat_vim_cmd = ":call repeat#set(\"". tabularize_cmd . "<Bslash><lt>CR>\")"
        let keymap_cmd = a:first_key . second_key . " " . tabularize_cmd . "<CR>" . repeat_vim_cmd . "<CR>"
        execute "nnoremap " . keymap_cmd
        execute "vmap " . keymap_cmd
    endfor
endfunc

call s:make_align_mappings(
    \ "<leader>a"
    \,[':' , "\/:\\zs/l0r1"]
    \,[',' , "\/,\\zs/l0r1"]
    \,['=' , "\/[^=]=[^=]/l1r1"]
    \,['\~', "\/==/l1r1"]
    \,['+' , "\/+/l1r1"]
    \,['-' , "\/-/l1r1"]
    \,['\|', "\/" . '\|' ."/l1r1"]
    \,['\[', "\/\[/l1r1"]
    \,['\]', "\/\]/l1r1"]
    \,['m' , "\/^[^<]*<[^>]*>\\zs/l0r1"]
    \)

Bundle 'chrismccord/bclose.vim'
nnoremap <C-W>c :Bclose<CR>

if !s:isWin
    " Too slow on windows...
    Bundle 'airblade/vim-gitgutter'
endif

Bundle 'bling/vim-airline'
" Disable Tagbar for airline, too slow!
let g:airline#extensions#tagbar#enabled=0

if has("lua")
    Bundle 'Shougo/neocomplete'
    let g:neocomplete#enable_at_startup = 1
    let g:neocomplete#enable_smart_case = 1
    let g:neocomplete#text_mode_filetypes = {
                                            \ "pandoc": 1
                                            \ }
    inoremap <expr><C-g>    neocomplete#undo_completion()
    inoremap <expr><C-l>    neocomplete#complete_common_string()
    inoremap <expr><TAB>    pumvisible() ? "\<C-n>" : "\<TAB>"
    inoremap <expr><C-h>    neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><BS>     neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y>    neocomplete#close_popup()
    inoremap <expr><C-e>    neocomplete#cancel_popup()
else
    Bundle 'ervandew/supertab'
endif

Bundle 'jondkinney/dragvisuals.vim'
vmap  <expr>  <S-LEFT>   DVB_Drag('left')
vmap  <expr>  <S-RIGHT>  DVB_Drag('right')
vmap  <expr>  <S-DOWN>   DVB_Drag('down')
vmap  <expr>  <S-UP>     DVB_Drag('up')
vmap  <expr>  D          DVB_Duplicate()

Bundle 'scrooloose/syntastic'
let g:syntastic_check_on_wq=0
let g:syntastic_mode_map = { 'mode': 'passive'
                           \,'active_filetypes': []
                           \,'passive_filetypes': []
                           \}
nmap <silent> <leader>ss :SyntasticCheck<CR>
nmap <silent> <leader>sr :SyntasticReset<CR>
let g:syntastic_haskell_checkers=['hlint']

Bundle 'vim-pandoc/vim-pandoc-syntax'
let g:pandoc_use_embeds_in_codeblocks_for_langs = [
    \ "python"
    \,"haskell"
    \ ]

Bundle 'vim-pandoc/vim-pantondoc'
let g:pantondoc_use_pandoc_markdown = 1
" let g:pandoc_use_conceal = 0

Bundle 'vim-scripts/glsl.vim'
au BufNewFile,BufRead *.shader set filetype=glsl.c

" Bundle 'nosami/Omnisharp'
" let g:Omnisharp_start_server = 0
" let g:Omnisharp_stop_server = 0
" au filetype cs nmap <buffer> <leader>gs :OmniSharpStartServer<CR>
" au filetype cs nmap <buffer> <leader>gt :OmniSharpHighlightTypes<CR>
" au filetype cs nmap <buffer> <leader>gd :OmniSharpGotoDefinition<CR>
" au filetype cs nmap <buffer> <leader>gu :OmniSharpFindUsages<CR>
" au filetype cs nmap <buffer> <leader>gr :OmniSharpGetCodeActions<CR>
" au filetype cs nmap <buffer> <leader>ge :OmniSharpFindSyntaxErrors<CR>

Bundle 'dhruvasagar/vim-table-mode'
let g:table_mode_corner = '+'

Bundle 'tomtom/tcomment_vim'
nmap <C-i> gccj
vmap <C-i> gc

Bundle 'scrooloose/nerdtree'
nmap <F6> :call g:vimrc_toggle_nerd_tree()<CR>
let g:vimrc_initial_nerd_tree=1
function! g:vimrc_toggle_nerd_tree()
    if (g:vimrc_initial_nerd_tree==1)
        execute ":NERDTreeCWD"
        let g:vimrc_initial_nerd_tree=0
    else
        execute ":NERDTreeToggle"
    endif
endfunc
let g:NERDTreeHighlightCursorline=1
let g:NERDTreeWinPos="right"
let g:NERDTreeShowLineNumbers=1
let g:NERDTreeMinimalUI=1
let g:NERDTreeIgnore = [
    \ s:ignore_files . '[[file]]'
    \,s:ignore_dirs . '[[dir]]'
    \ ]
autocmd FileType nerdtree call s:nerdtree_settings()
function! s:nerdtree_settings()
    let &nu=0
    let &relativenumber=0
endfunc
nnoremap <leader>ff :NERDTreeFind<CR>

Bundle 'majutsushi/tagbar'
nmap <F5> :TagbarToggle<CR>
let g:tagbar_left=1

Bundle "nelstrom/vim-visual-star-search"
Bundle 'thinca/vim-visualstar'
nmap * <Plug>(visualstar-*)N

Bundle 'milkypostman/vim-togglelist'
nmap <script> <silent> <leader>l :call ToggleLocationList()<CR>
nmap <script> <silent> <leader>q :call ToggleQuickfixList()<CR>

Bundle 'vim-scripts/toggle_words.vim'
nmap <leader>\ :ToggleWord<CR>

Bundle 'tyru/open-browser.vim'
let g:netrw_nogx = 1
nmap gx <Plug>(openbrowser-smart-search)
vmap gx <Plug>(openbrowser-smart-search)

Bundle 'kien/ctrlp.vim'
let g:ctrlp_max_depth = 20
let g:ctrlp_map = '<C-P>'
let g:ctrlp_clear_cache_on_exit = 0
let g:ctrlp_cmd = 'CtrlPCurWD'
let g:ctrlp_custom_ignore = {
    \ 'dir':  s:ignore_dirs,
    \ 'file': s:ignore_files
    \ }
let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'dir', 'rtscript',
                        \ 'undo', 'line', 'changes', 'mixed', 'bookmarkdir']
nnoremap <silent> <C-B> :CtrlPBuffer<CR>
nnoremap <leader>fr     :CtrlPMRU<CR>
nnoremap <leader>fb     :CtrlPBookmarkDir<CR>
nnoremap <leader>fd     :execute ":CtrlPDir ".fnameescape(getcwd()) <CR>
nnoremap <leader>fs     :CtrlPRTS<CR>
nnoremap <leader>fu     :CtrlPUndo<CR>
nnoremap <leader>fl     :CtrlPLine<CR>

Bundle 'dbakker/vim-projectroot'
nnoremap <leader>cd :ProjectRootCD<cr>

" }}}
" Global preferences {{{
" ------------------------------------------------------------------------------
if (s:is_initial)
    syntax on
endif
set noswapfile
set lazyredraw
set sessionoptions-=options
set sessionoptions-=folds
set viminfo='50,<1000,s100,n~/.viminfo
set autoindent
set backspace=indent,eol,start
set complete-=1
set showmatch
set smarttab
set nrformats-=octal
set shiftround
set ttimeout
set ttimeoutlen=50
set exrc
set hidden
set nospell
set showcmd
set incsearch
set hlsearch
set number
set norelativenumber
set nowrap
set ruler
set linebreak
let &showbreak='... '
set cursorline
set ignorecase
set smartcase
set expandtab
set tabstop=4
set shiftwidth=4
set softtabstop=4
set textwidth=80
set foldmethod=syntax
set foldlevelstart=99
set formatoptions-=t
" set foldcolumn=3
autocmd FileType qf wincmd J " quickfix list at bottom
set wildignore=*.o,*.obj,*.bak,*.exe,*.pyc,*.swp
set wildignore+=*.png,*.tga,*.psd
set wildignore+=*.class,*.jar
set wildignore+=*.meta,*.prefab
set suffixes+=.class,.exe,.o,.obj,.dat,.dll,.aux,.pdf,.gch
set wildmenu
set wildmode=longest:list,full
set laststatus=2
set ttimeoutlen=50
set enc=utf-8
set fileencoding=utf-8
set fileencodings=ucs-bom,utf8,prc
exec "set listchars=tab:\\|â†’"
exec "set list lcs+=trail:\uB7,nbsp:~"
" }}}
" Theme  {{{
" ------------------------------------------------------------------------------
set colorcolumn=+1

" Random Colors {{{2
func! Rand(lower, upper)
" Gets random number in range (lower, upper)
python << EOF
import vim, random
r = random.randint(int(vim.eval('a:lower')), int(vim.eval('a:upper')))
vim.command('return ' + str(r))
EOF
endfunc

func! SetRandomColorScheme(colors)
    let color = ""
    if (g:chosen_color != "")
        let color = g:chosen_color
    else
        let color = a:colors[Rand(0, len(a:colors) - 1)]
    endif

    " Load the color scheme
    execute 'colorscheme ' . color
    let g:chosen_color = g:colors_name

    " Cursor line default colors
    let cursor_line_normal_bg = "#333333"
    let cursor_line_insert_bg = "#002143"

    hi! link Conceal Operator

    " Overwrites
    if (g:colors_name == "molokai")
        hi! link ColorColumn WarningMsg
    elseif (g:colors_name == "candyman")
        let cursor_line_normal_bg = "#222222"
        hi! link ColorColumn SpecialKey
    elseif (g:colors_name == "jellybeans")
        let cursor_line_normal_bg = "#222222"
        hi! link ColorColumn SpecialKey
    elseif (g:colors_name == "xoria256")
        hi! link ColorColumn VertSplit
    elseif (g:colors_name == "herald")
        if has("gui_running")
            hi! link ColorColumn StatusLine
        else
            hi! link ColorColumn StatusLineNC
        endif
    elseif (g:colors_name == "lilypink")
        hi! link ColorColumn StatusLineNC
    elseif (g:colors_name == "wombat256mod")
        hi! link ColorColumn SpecialKey
    elseif (g:colors_name == "inkpot")
        hi! link ColorColumn LineNr
    elseif (g:colors_name == "pf_earth")
        hi! link ColorColumn LineNr
    elseif (g:colors_name == "kolor")
        hi! link ColorColumn LineNr
    elseif (g:colors_name == "lodestone")
        if has("gui_running")
            hi! link ColorColumn LineNr
        else
            hi! link ColorColumn Pmenu
        endif
    elseif (g:colors_name == "graywh")
    endif

    " Set the cursor line color
    execute "hi! CursorLine guibg=".cursor_line_normal_bg." guifg=NONE"
    execute "au InsertEnter * hi! CursorLine guibg=".cursor_line_insert_bg." guifg=NONE"
    execute "au InsertLeave * hi! CursorLine guibg=".cursor_line_normal_bg." guifg=NONE"

endfunc
" }}}2

if has("gui_running")

    let colors = []
    call add(colors, "candyman")
    call add(colors, "jellybeans")
    call add(colors, "lilypink")
    call add(colors, "wombat256mod")
    call add(colors, "pf_earth")
    call add(colors, "kolor")
    call add(colors, "lodestone")
    call add(colors, "herald")
    call add(colors, "solarized")
    call SetRandomColorScheme(colors)

    " TagHighlight classes
    highlight Class guifg=#5199C0
    highlight LocalVariable guifg=#ffffff
    highlight Function guifg=#F4F885

    if (s:isWin)
        set guifont=Consolas:h11:cANSI
    else
        set guifont=DejaVu\ \Sans\ Mono
    endif
    set guifontwide=NSimsun:h12
    set guioptions-=m
    set guioptions-=e
    set guioptions+=c
    set guioptions-=l
    set guioptions-=L
    set guioptions-=r
    set guioptions-=R
    set guioptions-=b
    set guioptions-=T
else
    set t_Co=256
    if (s:isLinux)
        let colors = []
        call add(colors, "xoria256")
        call add(colors, "candyman")
        call add(colors, "jellybeans")
        call add(colors, "kolor")
        call add(colors, "lodestone")
        call add(colors, "herald")
        call SetRandomColorScheme(colors)
    endif
    hi CursorLine term=NONE cterm=NONE ctermbg=236
endif
" }}}
" Filetypes {{{
" ------------------------------------------------------------------------------
" Adobe extend script 
autocmd BufRead,BufNewFile *.jsx setlocal filetype=javascript
autocmd BufRead,BufNewFile *.jsxinc setlocal filetype=javascript
autocmd BufRead,BufNewFile *.mxi setlocal filetype=xml

" CSharp
autocmd BufRead,BufNewFile *.cshtml setlocal filetype=xml.javascript

" ActionScript3
autocmd BufRead,BufNewFile *.as setlocal filetype=as3

" Java
let java_highlight_all=1
let java_highlight_debug=1
autocmd filetype java setlocal suffixesadd+=.java

" Unity Shaders
autocmd BufRead,BufNewFile *.shader setlocal filetype=cg

" Dart
autocmd BufRead,BufNewFile *.dart setlocal filetype=dart

" HTML
autocmd filetype html setl shiftwidth=2

" Python
autocmd filetype python setlocal foldmethod=indent

" Ruby
autocmd filetype ruby setl shiftwidth=2

" Rails asset pipeline
autocmd BufRead,BufNewFile *.slim set filetype=slim

" Haskell
au filetype haskell nmap <script> <buffer> <localLeader>r :!runhaskell %<CR>
au filetype haskell nnoremap <script> <buffer> <LocalLeader>t :GhcModType<CR>
au filetype haskell setl omnifunc=necoghc#omnifunc

" }}}
" Goodies {{{
" ------------------------------------------------------------------------------
" Open file with pre-existing swp file in read-only automatically
augroup NoSimultaneousEdits
    autocmd!
    autocmd SwapExists * let v:swapchoice = 'o'
    " autocmd SwapExists * echomsg ErrorMsg
    autocmd SwapExists * echo 'Duplicate edit session (readonly)'
    autocmd SwapExists * echohl None
    autocmd SwapExists * sleep 2
augroup END

" Open a help in a vertsplit. Use with `:Vh`
command! -nargs=* -complete=help Vh vertical belowright help <args>

" Working directory per tab
au TabEnter * if exists("t:wd") | exe "cd" . '"' t:wd . '"' | endif 
au TabLeave * let t:wd=getcwd()

" }}}
"
" Random stuff:
" Custard Square {{{
" ------------------------------------------------------------------------------
" Start the smartfox server
func! StartSFS2X()
    execute 'Start ' . $SFS2X . '/restartSFS2X.bat' 
endfunc
nmap <silent> <leader>ws         :call StartSFS2X()<CR>
" }}}
" Tracking {{{
" ------------------------------------------------------------------------------
func! TrackerAddItem()
    let b:ve=&ve
    set ve=all
    execute 'normal 0$  v80|r-$hhhhxxxxx iOPEN'
    let &ve=b:ve
    unlet! b:ve
endfunc

func! TrackerCloseItem()
    execute 'normal 0 /OPEN$/ciwDONE'
endfunc

func! TrackerOpenItem()
    execute 'normal 0 /DONE$/ciwOPEN'
endfunc

nmap <silent> <leader>ma        :call TrackerAddItem()<CR>
nmap <silent> <leader>mc        :call TrackerCloseItem()<CR>
nmap <silent> <leader>mo        :call TrackerOpenItem()<CR>
vmap <silent> <leader>ma        :call TrackerAddItem()<CR>
vmap <silent> <leader>mc        :call TrackerCloseItem()<CR>
vmap <silent> <leader>mo        :call TrackerOpenItem()<CR>
" }}}
" {{{ Convert AS3 to dart
" func! ConvertAsToDart()
"   execute '%s/\<var\>//'
"   execute '%s/\<private\>//'
"   execute '%s/\<protected\>//'
"   execute '%s/\<public\>//'
"   execute '%s/\<override\>//'
"   execute '%s/\<uint\>/int/'
"   execute '%s/\<function\>//'
"   execute '%s/\<Number\>/num/'
"   execute '%s/\<Boolean\>/bool/'
"   execute '%s/\<Math\.max\>/max/'
"   execute '%s/\<Math\.min\>/min/'
"   execute 'normal >>'
"   execute 'normal <<'
" endfunc
" nmap <silent> <leader>c :call ConvertAsToDart()<CR>
"
" }}}

